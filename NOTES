#+TITLE: Meteo Development Notes
#+STARTUP: showall
#+OPTIONS: H:3 num:nil toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t TeX:t LaTeX:nil skip:t d:t tags:not-in-toc

* 06/10/2011 Friday
** Spreadsheet/hash representation 				      :table:
I was considering the similarity between the internal music layout and
a spreadsheet.  Took a quick look at the gnumeric internals as it
would give a decent idea of how insertion/deletion would work.  The
internal representation is a =g_hash_table= which is used fo
insertion/deletion.  Empty cells simply don't exist in the hash and
have a default display.  When a row or column is inserted, cells
beyond the region are scanned and their position is updated.

In my case, I would index by measure and part, either part name or
number.  This would give these approximate tradeoffs compared to the
measure-wise linear representation.

|--------------------------------+------+------+-----+---------------------------------|
| Operation                      | Freq | Hash |  MW | Notes                           |
| Score                          |      |  652 | 650 |                                 |
|--------------------------------+------+------+-----+---------------------------------|
| In-measure move                |   10 |   10 |  10 | Both right/left                 |
| Accross-measure move           |    8 |    8 |   8 | Lookup vs up, right, part       |
| Next/prev part                 |    7 |    8 |   9 | Lookup vs next part             |
| In-measure edit                |   10 |   10 |  10 | Both direct                     |
| Accross-measure edit           |    7 |    8 |   7 | Lookups vs MW must track rect   |
| In-measure multipart edit      |    7 |    8 |   8 | Lookups vs direct for MW        |
| Accross-measure multipart edit |    5 |    8 |   7 | Lookups vs track rect for MW    |
| Synch of aligned measures      |   10 |    8 |   9 | Lookups vs MW is direct         |
| Measure insertion/deletion     |    7 |    4 |   8 | Hash must iterate, MW is direct |
| Part insertion/deletion        |    4 |    4 |   4 | Hash must iterate, MW must walk |
| Jump to measure                |    7 |    8 |   3 | Lookup vs MW walk               |
|--------------------------------+------+------+-----+---------------------------------|
#+TBLFM: @2$3=vsum(@II..@III * @II$2..@III$2)::@2$4=vsum(@II..@III * @II$2..@III$2)

The part insertion may not be a factor for either representation
assuming I can implement some sort of default display for missing
parts.  However, this will make much more sense in the Hash
representation as we'll have to deal with default displays for empty
"cells" (measures in a part) in a lot of cases.

Using a hash would alleviate the need for zippers to some extent.
Measure/part coordinates can be used much more directly and
whole-measure rectangles are much easier to represent as their own
hashes.  In copying a region, I might make use of transients to speed
creation.  There is still the need to scan around in beats which may
be better represented using zippers, but since measures are relatively
much shorter, they can be created quickly, moved through, then
discarded.  Thus we don't need to keep a cache of zippers around.

For copy/paste, we'd also have direct access to the notion of the
Mectangle rather than having to worry about which parts are there.  A
Mectangle just becomes a hash indexed by measure and part number
rather than part name.  This is a lot simpler than the other
structures I was thinking of, both in terms of its creation and
insertion. 

The key feature of the Hash representation is how fast lookup happens.
I'm just guessing above that the a hash-map will have lookup speed
only slightly slower than going up and over in the list
representation.  If this turns out to be wrong, a lot of basic
operations would probably suffer.  Even a small reduction in speed
will cause the measure-wise representation to be faster.  The only
real gain will be in terms of directly jumping.  This will still have
applications for graphical access: very little scanning will be needed
to get to an arbitrary location.

A lot of the techniques that are applied in gnumeric can be copied
which will make implementation a little easier (not re-inventing the
wheel).  It is also comforting to see that gnumeric runs pretty fast
even for the expensive row/col insertion operations.  The slowest part
seemed to be undoing an insert/delete.

** Emacs Undo power
Was looking at [[info:emacs#Undo][emacs undo]] and it turns out it has region-specific undo
capability.  This is sort of stunning: undo changes only in a
highlighted region.  I'm not sure that I can replicate this one in
meteo, but keep it in mind.

** Layout tactics
A couple ideas on layout production

- Use a pass to create objects and constraints between objects
- Score objects each get a series of fields
  - :layout has layout objects and their corresponding variables 
  - :constraints have symbols in equations form
  - :variables are the variables for the object 
- Use a second pass to accumulate

Working backwards, to draw the score, I'll need to traverse the score
executing drawing instructions.  This will look something like:
- Start at the upper left coordinates 
- Enter the first part and create a context based on the part
- Enter the first measure adding to the context
- Obtain the coordinates of the first measure move the cursor there
- Draw a staff using the width of the measure
- Enter the measure's layout objects (staff, time/key sig, markings)
- For each object retrieve its glyph and coordinates and draw them
- Enter the measure's entries (notes/chords)
- For each entry, enter it's layout objects

Trying to get a uniform layout routine.  Would like to have layout
objects, then move to children which also have layout objects.  This
would make drawing very easy, need to be careful of relative positions
of coordinate systems.  Move to parent's 0 position, draw layout
objects relative to it.  Then traverse children.  Move to child's
position, then recurse on it.  This would start to diverge from
maintaining the correspondence between logical and layout
representations.  It would also allow more flexibility with modifying
the layout.  

For example, the objects/children model allows system breaks much more
easily than the the logical structure in the page view.

- We start with one system for the page and determine approximate
  measure widths and heights for each using a cheap function.
- Then break the global system into multiple systems on multiple pages
  according to the first estimate.
- Add pages as children to the score; add systems as children to each
  page; add page objects (page number, part id) to each page
- Optimize layout for each measure/system to get positions and new
  widths/heights
- Return to page level, optimize systems and page level objects
- If conflicts arise, readjust the measure to system assignment and
  repeat measure-level and page-level layout optimizations

At each step for drawing, it's simply a matter of traversing the
objects at each level and then descending to the children: 
- global 
- pages: title, composer, page# 
- systems: 
- parts: part names, staffgroups
- staves
- measures: clef, time/key sig, expressions
- voices:

This may actually call for some further research into drawing as
dictated by the need to draw on a page.

** Mid-measure clef changes
Inserting a clef mid-measure complicates a number of things
- Does the clef belong to a particular voice?  How is it tracked?
- Subsequent measures must be adjusted to the new clef - do the adjust
  based on their current pitch or current line?
- Insertion of notes in the measure must be relative to the new clef -
  changing from treble to bass, pressing 'c' to insert a c must pick
  the proper position
- The above means insertion is not easy, must scan backwards to the
  nearest clef


* 06/06/2011 Monday

** Strange loop conference
https://thestrangeloop.com/

Could be interesting if I have time for it.  Early registration ends
July 19, Rich Hickey is the first keynote speaker and Guy Steele spoke
last year.

Videos from last year
https://thestrangeloop.com/news/strange-loop-video-schedule


** ILP Tutorial
http://www.ie.boun.edu.tr/~taskin/pdf/IP_tutorial.pdf
May be useful to get ideas on coding solution algorithms.

* 06/01/2011 Wednesday

** Kevin on github
https://github.com/deronnek/dotenv

* 05/31/2011 Tuesday

** A better ILP solution
Here is a simplified representation of stems as an ILP.

- Top chord note A and bottom B, MAX is longest stem length 
- 2 control points u for down stem, v for up stem
- s=0 is down, s=1 is up, t is point for the flag/beam
- y(u) >= y(B)
- y(u) <= y(B) + MAX - MAX*s
- y(v) <= y(A) 
- y(v) >= y(A) - MAX*s
- y(t) = [y(u) - y(B)*s] + [y(v) + y(A)*s - y(A)]

The two control points u,v are bounded above and below.  When one is
active, it has a range, when not, it is forced to be at the top/bottom
note.  The flag control point is determined by adding u and v but
subtracting their inactive values.

** TODO Slowing down
Going to have to slow down on meteo for a while to return to
research.  Here are the high priority concerns at this point.

- Need a solver for the ILPs that I will construct
- Need to settle on the description language and framework of
  construction when setting up the layout problem
- Still haven't settled on where to store layout information
  - Is it meta info to preserve the logical data structure
  - Or is it just a field
  - What is the difference between a set up layout and a solved layout


* 05/27/2011 Friday

** Not integer programming exactly
After some additional attention, it seems that the layout problem is
not well characterized in the framework of linear integer
programming.  A number of binary decisions must be made on which
additional layout objects depend.  For example
- Determine stem up or stem down
- This dictates the left/right note placement of 2nds
- It also dictates up or down orientation of flags or the control
  point to be used for beaming
These are discrete choices that can't be easily represented by the
framework I'm laying out.  

I think what I'm going to need is a discrete search. This is requires
that each pass of adding objects use some language about choices that
are available.

Scratch that, found an ILP solution to this.

** ILP Solution
First, detect that a 2nd appears.  This will necessitate a combined
note head, stem, flag, and possibly accent constraint generation.

This divides into two cases: s=0 for upward stems and s=1 for downward
stems.  In both cases, there are invariant expressions for where
everything will land.  Ex:
- 3 notes, a,b,c and 2 stem control points u,v, flag f and accidental r
- s=0 is upward stems, s=1 is downward stems
- Let h be the height difference between a (top note) and b (bottom
  note)
- The 2nd is between b/c (middle bottom)
- Horizontal constraints on note heads
  - x(a,c) = x(u) - w + w*s (left for s=0, right for s=1)
  - x(b) = x(u) - ws (right for s=0, left for s=1)
  - The vertical constraints are fixed for a, b, c
- Vertical constraints on the stem
  - y(u) <= y(v) (u is above v)
  - y(u) <= y(a) + h*s  (above a for s=0, above c for s=1)
  - y(v) >= y(a) + h*s  (below c for s=0, below a c for s=1)
  - Actually after considering this further, it doesn't really
    guarantee what I want it to do.
- Flag vertical position
  - x(f) = x(u)
  - y(f) = y(u) + y(v) - h*s
- Accidental position
  - Desired offset off from note head
  - y(r) = y(a) - hs + h + off - 2*off*s
  - x(r) = x(a)

This needs some refinement because it doesn't represent the actual
constraints I need for stems, but it's closer.

** Discrete search space
This raises the question: how does one describe a discrete search
problem in lisp?

I think we'll need a constraint language similar to the one I started
using for matrices.

>>>>>>> 6020f18e8a39554afffc632bd9a734e5abb84d23

* 05/26/2011 Thursday

** Tuple Rhythms
I neglected tuple rhythms in my initial pass at rhythms.  This will
require a little rethinking of the representation, perhaps just
including a tuple designator.  I updated the Notes protocol to include
this. 

** Layout Next steps
If I am going to set up an integer program for the layout of measures,
I'll need to create the framework carefully.  I need to treat the
context very carfeully as I build the program.  According to the below
discussion, I'll need to be tracking, Boxes, Constraints, and Target
functions.  In addition I need to provide a context in which other
objects can be 'looked up' such as the note head for the current
object.  

At first pass, this looks like a parent relationship.
- A lot of objects have parents which are Pitch or Notes like heads,
  stems, dots, accidentals, articulations and possibly also note-tied
  expressions like dynamics
- Some objects can have Measure parents such as tempo, key sig,
  dynamics, chords

However, there are a bunch of other objects that need something more
- Beams have potentially many notes participating in them
- Slurs and ties have at least two parents
- Notes themselves may be cross-staff beamed making their parents
  ambiguous (deal with this case later)

In the case of the beams, we'll have two end points of the beam
constrained to two note x positions and their stem y positions.
However, getting the other note stems to match this may add bad
nonlinear constraints.  Consider 3 note stems a2 b2 c2 (denoting the
second control point, "top" of stem) and beam with points d1 d2.
Constraints will be something like 

x(d1) = x(a2)   y(d1) = y(a2)
x(d2) = x(c2)   y(d2) = y(c2)
y(b2) = (y(a2) + y(c2))/2

This actually doesn't look as bad.  There may be some trickiness with
getting the right offsets when padding is involved, but I think I can
restrict myself to adding these thre constraints which are linear.

For doing beam analysis, I'll need to be able to retrieve the ids of
the stems of all the notes to be beamed.

** Setting up context for Layout
Need to track 
- IDs of objects added and their logical owner
- Boxes
- Constraints
- Targets
I started out doing this by associating everything with the objects
themselves through meta data.  This preserves the logical structure
exactly.

** TODO Note head layout
- Add boxes for all notes
- Add constraints for ypos of each note
- Check to see if notes are height 1 apart
- If no notes are 1 apart, then constrain all heads to have xpos of
  top head
- If there are notes with ypos diff of 1, require offsets between xpos
  of offending notes
- This also requires heads to change sides based on stem direction, up
  or down
- This looks very hard right now without an understanding of how do
  stems so I'll leave closely spaced pitches for later


** TODO Font problems on Linux
I was trying to run the fonts.clj trialcode at school and ran into
problems, it appears there is some sort of font problem with the
Font/TRUETYPE_FONT not agreeing with the opentype font Emmanteler.  It
works fine at home but gives a FontFormatException claiming the font
type is unsupported.

According to this post, it may not be supported because it may be a
TrueType font internally which is no good on linux.
http://mindprod.com/jgloss/opentype.html
I'll probably want to convert this to the OTF with "PostScript Adobe
CCF internally" which seems to have the best support.  However, the
fact that the current version worked at home on the virtual machine is
not comforting for compatibility.  

Check the java versions used between home and school.

** defnk for keywords
There is a macro =clojure.contrib.def/defnk= which allows keyword
specification of function arguments.  Useful in a lot of cases though
it screws up the doc string.

** Lack of IP solvers for java
There is a lack of IP solvers for java, all that seems to exist are
hooks into C libraries.  This concerns me some.  Options are port a C
version or try to cast the problem in a different way.  In general,
there seem to be a lack of any good numerical libraries for java.  It
occurs to me now that most of those ILP solvers are not online: they
only produce solutions at convergence which might cramp the UI
experience quite a bit.

I might have to investigate constraint satisfaction problems in Lisp
as an alternative.

* 05/25/2011 Wednesday

** Debugging
Recall that to set a break point in code do
#+BEGIN_SRC clojure
(require 'swank.core)
...
(swank.core/break)
...
#+END_SRC
This only breaks and allows the inspection of local variables.

** The unforgiving compiler
I got a weird error when trying to compile a file
: Unknown location:
:  error: java.lang.ClassCastException: java.lang.Character cannot be cast to clojure.lang.IObj
After 10 minutes of playing, I started to do an incremental compile
which led to the problem being a mistake in the syntax of a
=defprotocol=, a comment was not associated with its method
correctly.  The message was thoroughly unhelpful, something I will
probably be able to look forward to a lot.  Liberal use of evaluation
of expressions in the REPL may help.

** defvar
Putting =(:use [clojure.contrib.def])= in the =ns= declaration allows
=defvar= to be used
#+BEGIN_SRC clojure
(defvar dot-dist 1
  "Preferred distance from edge of bounding box of note heads")
#+END_SRC

** Layout
Begun looking at layout and here is the way I envision things working.
Each logical music object gets meta-data associated with it which
describes the layout objects needed.  Each layout object is a key-val
pair in the meta-data map.  Each key is the name (:head, :dot), and
the value is a little language of constraints which describes how to
get the positions of this element, possibly with respect to other
elements.  

A better approach occurred to me in the evening.  The right thing to
do here is treat this as a constrained optimization problem right off
the bat.  This involves the creation of boxes, constraints, and
objective terms.  The boxes will be added to objective to check for
collisions.  Some examples

- Note heads a,b,c
  - Add a box around the note, box(a) box(b) box(c)
  - Constraint: ypos has a fixed value, ypos(a)=const, ...
  - Constraint: spaced notes in the same Notes must have equal
    xpos. Notes have xpos(a)-xpos(b)=0 and xpos(a)-xpos(b)=0
  - Constraint: if ypos between two notes is only 1, fix xpos to be
    glyph width apart, higher note a is to the right
    xpos(a)-xpos(b)=width, set split flag for notes
- Stem u,v for notes a,b,c
  - u is at notes, v is tip of stem
  - Add line with coords x(u) y(u) x(v) y(v)
  - Constraint xpos(u)-xpos(v)=0
  - If split is set for notes, determine a is split out
    - Constraint xpos(u)-xpos(a)=0
  - Otherwise have binary var s for xpos of u
    - Constraint xpos(u)-xpos(a)+width(a)*s=0
  - Target ||ypos(u)-ypos(v)||-dist
- Dot d for Notehead n
  - Box(d)
  - Constraint xpos(d)-xpos(n)=1+width(n)
  - Constraint ypos(d)-ypos(n)=0
- Ledger lines
- Accidentals
- Beams
- Articulation markings
- Slurs and Ties
  - Can require multimeasure analysis
  - Will probably model with two end points and a control point
  - Binary choice: up slur or down
- Tuple
- Clef Sign
- Key signature and changes
- Time signature and changes
- Performance instructions
- Cres/decresc
- Lots of other stuff

This will allow a 0-1 integer solver to handle the problem.

* 05/24/2011 Tuesday

** Magit
Experimenting with Magit as a git interface in emacs to get commits
done faster.  Has push pull capability also.  Works with "staging" -
the notion of git add I think.  Can largely ignore this for now but
may become more important later, just use the =S= to stage all changes
and =c= to commit them.

| C-x m | magit-status, my binding to pull up revision control |
| c     | Commit changes, if none staged, operate on changes   |
| s     | Stage file                                           |
| S     | Stage all changed files                              |
| u     | Unstage file                                         |
| U     | Unstage all staged files                             |
| P P   | Push commits to remote                               |
| F F   | Pull commits from remote                             |

Magit also has a nice key-popup buffer which is in magit-key-mode.el
and worth a look for more emacs hacking.

Manual is at http://magit.github.com/magit/magit.html
Git tutorial http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html

** PDF export in Umlet
Check this out as an insight into how to get my own pdf export
working. 

** Note ranges
I'll probably mostly use keywords for note names =:Bb5= and =:C10=
which will require a little parsing.

** Multimethods vs. Protocols
It seems that multimethods and protocols conflict just a little bit.
Defining a protocol creates multimethods for each of the methods
defined.  These are automatically set up in single dispatch form
however and trying to define a multimethod with dispatch on more
arguments causes problems

** Swank trouble
Had some trouble at school getting swank running under lein.  There is
a =lein jack-in port= command that can be used inside =M-x
clojure-jack-in= which is supposed to bootstrap the right slime file,
but I haven't gotten it to work right.  The alternative that works is
=lein swank= in the project directory.  This requires that leiningen
installs the right plugin there by doing 
: lein plugin install swank-clojure 1.3.0
but gives access to all of clojure.contrib which is really nice.

** Note durations
Trying to come up with a way to do note durations effectively.  I'll
want symbolic representations =:eigth :quarter= and will probably use
=:quarter.= to represent the dotted versions.  Figuring out width is a
little trickier.

* 05/23/2011 Monday

** Git merge
When a conflict arises, edit the conflicting file manually and then
: git commit -a -m 'msg'
to commit.

** Indirection 
I'll use some sort of ref type as the mode of indirection to enable
mutation.  Have note decided yet which is most appropriate (ref, atom,
agent, or var).  For example, a buffer will essentially be a control
structure which has
- A score ref, potentially shared with other buffers
- A layout ref watching the score agent
- A display ref watching the layout agent
A command making a change to the score does so with funcitons in the
=Edit= protocol.  A command should probably block until the edit
finishes which probably means using refs.  This update is recognized
by the layout updater which then runs on the current value of the
score and re-optimizes for changes.  Then the display notices the
changes in the layout and updates the view of it.

This is actually sort of tricky.  Here is a simple sequence of events 

A call like
: (insert score '(1,1,2) {:pitch C4 :dur 4})
is made which will put a note in the first measure, first beat of the
second part.  We actually want to mutate the score here, so it would
look more like
#+BEGIN_SRC clojure
(ref score)                             
(dosync
 (alter score insert '(1,1,2) {:pitch C4 :dur 4}))
#+END_SRC
The question is, do we use protocols to mean mutation or only
production of the new persistent version of the data.  This is
important because of where the dosync happens.  In the above, the
=Edit= protocol implies nothing of the complexity of insert.  It locks
up the score and runs the function, potentially retrying if need be.
This could potentially lead to along delay, but it seems to make more
sense to lock down the score while an edit happens.  

For efficient insertion, we'll want to cache certain markers, in
particular the point which should have cheap insertion.  The series of
events would be something like
- The =insert= function is called with the coordinates of the point
- In the implementation, we look in the cache of marks and see that
  there is a valid zipper for that set of coordinates
- The edit is done using something like zip/edit and the edited score
  is retured with zip/root
- A higher level function which inserts at the current point will be
  called to move the point beyond the current stuff, it is not the
  responsibility of the low-level insert to do that
- If there is no cached zipper, another approach can be taken. 
  - Create the zipper for the given coordinates and proceed add it to
    the cache
  - Modify the score in a more direct manner
- Once the score is modified, markers need to be updated, potentially
  invalidating zippers they might have.  This creates a circularity
  problem because we don't want to invalidate the marker which we just
  used to make the change.
- I'll need to use edit sequences for this and make sure that the
  marker update doesn't invalidate markers at the point of edit
  - Insertion: the marker stays at the insertion point so it looks
    like it precedes the change. Ex: insert notes at (2,3,1), marker
    stays at (2,3,1) and the update uses a <= to check for whether it
    needs to be updated
  - Deletion: two markers are used. If neither is cached, create the
    ending marker. Deletion should happen at < the end marker
    - For an ending cached marker, back up one step and work backwards
      using zip/remove objects until the marker position is <= to the
      beginning position of deletion
    - For a beginning cached marker, move forward to just before the
      ending marker and then perform the ending marker operations
    - Ex: Delete between (2,3,1) and (3,4,2); starting at (3,4,2),
      back up one note and then delete notes in part 2 until the
      beginning of the measure is reached, then move to (3,4,1) and do
      the same. Then move back a measure, delete notes down to and
      including (2,3,2) and (2,3,1).  This leaves the note formerly at
      (3,4,1) at (2,3,1) and likewise (3,4,2) at (2,3,2).  It leaves
      the point at (2,3,1) which should satisfy the <= for checking
      whether a marker should have its zipper invalidated

** Are zippers a good idea?
I played around in notes.clj again with the efficiency of zippers.  It
seems at least for the simplified note representation that I'm using
that they are pretty fast.  The approach was to define a sequence of
parts where
- Each part had a modification
- The modification is made at the point position
- zip/root is called to save the part
This could create 4K parts with single note modifications in less than
a second.  This indicates using zippers will be fast enough in the
bulk of cases for score edits.  See the above node for additional
details.

** Behavior of delete
Deleting a region, a rectangular area, will call for different
behavior than a typical text editor.  If whole measures are selected
but not all parts are selected in the rectangle, the behavior is not
obvios.  I need to decide between these two possibilities
1. For the affected parts, clear the measures of notes leaving
   emptiness in its place but preserve the presence of measures.
2. Delete the measures in the affected parts shifting the remaining
   measures to the left to fill in.  Empty measures are added at the
   end of the score to compensate for length.  This is much harder in
   a measure-wise scheme as I'll need to completely rewire all the
   subsequent measures.  It is relatively easier in the part-wise
   arrangment.
I'm thinking (1) is the more common behavior as we don't typically
want shifting individual parts to occur.  That said, I'll probably
want to set up some code at some point to make this happen.  Recall
that inserting and deleting measures for all parts is a relatively
easy operation in the measure-wise orientation and probably commmon
enough to merit their own operations.


** Behavior of insert
Inserting is a little more subtle than what I originally thought.
- When you kill the region, but then immediately yank, you want the
  same state as before
- What does it mean to insert a Mectangle at the beginning of a filled
  measure?  If the mectangle does not contain more than one measure,
  it seems reasonably to insert the notes before the notes in the
  current measures and move those notes to the right in the current
  measure
- If the mectangle contains a measure break, the behavior is hard to
  understand.  According to the kill/yank principle, a measure break
  in the mectangle means start inserting and when a measure break is
  reached, move to the next measure and continue inserting
- While this makes sense in the kill/yank case, it's confusing in the
  filled measure case
- Ex: insert =D.2 |C.1 E.1 C.2|= at =|E.1 * E.1 C.1| B.2 F.2|=
  according to the kill/yank paradigm this would give =|E.1 D.2 E.1
  C.1|C.1 E.1 C.2 B.2 F.2|*=
- Alternatively, we could use an replace paradigm giving =|E.1
  D.2 |C.1 E.1 C.2|*=.  This is contrary to the text editing behavior,
  but perhaps make more sense in the music setting
- We lose the nice single measure interpretation then of yanking new
  notes into a measure then
- Inserting will then require more subtlety in replace mode as the
  replaced notes need to be counted for overlapping beats.  For
  instance, for insert =C.1 C.1 C.1= into =|* D.4 |= a choice must be
  made between =|C.1 C.1 C.1 *|= and =|C.1 C.1 C.1 * D.1|= based on
  whether we eliminate the D or preserve its remaining beat.
- I am inclined to use the insert only paradigm along with and provide
  some quick commands which would allow the overwrite behavior to be
  accomplished.  For example doing a C-y would paste while C-u C-y
  would paste using overwrite.  After some use analysis, I can change
  this as needed.  Paste with overwrite is essentially
  - Calculate the paste size
  - Delete that mectangle
  - Insert the paste notes

** Fast highlight on switching
It will be important to be able to quickly enable temporarily
transient mark mode.  I'd like to be able to do this without the
C-space C-space convention, just turn the highlighting on for the
current region, what I have bound to C-c C-t right now.  In
emacs-friendly mode, C-t will probably be the right binding, and this
may actually work for windows-mac friendly will require something
else.  There will be a lot of key binding conflicts between
windows/linux. 

** Finish measure
I'd like to implement a couple functions bound to TAB and ENTER which
will be finish-measure-next-measure and finish-measure-next-part.
They add rests to fill the measure or eliminate extra notes (beyond
time signature) and move to the next measure or part down.  

** Score has parts map
If the score keeps a vector of parts in the order they are to appear
then each measure can keep a hash of its parts.  When drawing the
parts, the score order is referenced for the order.  For one level of
indirection, changing the order of parts becomes easy.  Information
about each part can also be stored there: instrument, transposition,
starting clef, etc.  Having this as a part of the score reference
which is watched by the layout manager will allow changes to be
immediately incorporated.


* 05/22/2011 Sunday

** Abstractions and Protocols
I've really been looking at things at too low of a level at this
point, considering implementation details of the logic structure and
so forth.  A more useful activity will be to get the large-scale
abstract structure of the editor in place.  With good interfaces
between the parts, I can get the system up and running then worry
about efficiency considerations of the various parts.  A good score
structure will provide certain operations and if I use that interface,
I can change the underlying implementation later without affecting the
other parts.

This is actually proving more difficult than I thought.  I need to
specify the protocols to keep the parts clean and separated.  This is
the first priority now.

** UML 
Trying to find a simple UML tool to some diagramming, but this is
proving more difficult.

Tried OpenModelSphere and it was a pain on windows, jar won't run on
linux.

Tried Umbrello, KDE style program, and it crashed repeatedly.

Found UMLet which is simple, runs under java, and works on linx.
Using this for now nad building a meteo UML ddiagram of protocols.

http://www.umlet.com/

* 05/21/2011 Saturday

** Ropes for data structure
Ropes are another interesting alternative to a linear representation.
They are a binary tree (not necessarily full) which log(n) complexity
for most operations.  With a zipper, fast iteration (movement from
point) would probably also be possible.  The wikipedia article is
pretty bad so look for the original paper to see details.  There are
several implementation links, including for ocaml and common lisp.

The rope would track measures to allow faster random access: O(log n).

** Other data structures
Has some good links: http://catch22.net/tuts/neatpad/17

Another link that is on this page with a very good discussion of using
balanced trees to do editing of hex files:
http://www.chiark.greenend.org.uk/~sgtatham/tweak/btree.html


* 05/20/2011 Friday

** Futures
Futures are going to be an excellent way to achieve concurrent
execution without sacrificing data structure sensibility.  Using
=future= a body is executed in a separate thread without blocking the
current thread.  At the point of dereferencing, if the computation has
not finished, the dereferencing thread blocks until it completes.
This makes things really easy to start spawning lots of threads
quickly.  This means I can essentially just spawn and use and things
will run in concurrently on their own.  There are probably more
complexities than this involved, but it's an encouraging start.

The only thing I'd like to add is some sort of timeout check - if it
takes longer than a certain amount of time, then cancel the future.
We'll always need an initial layout, but further refinements should be
timed.  So, I'll experiment and potentially use futures for initial
layouts if they are fast enough while a thread-based scheme will be
used for refinement.  A single layout refinement would look like
#+BEGIN_SRC clojure
(defn refine [init work timeout]
  (let [cur (atom init)			;Set initial state
	fut (future			;Spawn worker thread
	     (while true
	       (dosync (swap! cur work))
	       (Thread/sleep 0)))]	;Worker: pause to see if cancelled
    (Thread/sleep timeout)		;Main: Sleep until timeout
    (when (not (future-done? fut))	;Main: stop worker if still running
      (future-cancel fut))
    @cur))
#+END_SRC
This approach is a little dangerous as I found out that futures, even
when cancelled, sometimes don't get rid of the thread they were
running.  Adding a =(Thread/sleep 0)= seems to alleviate this.

I will write to the clojure group to find out what's happening here.

** Separating concerns
Things are getting complex in terms of representing logic
vs. layouts.  The layout is intermediate and belongs to a buffer, keep
that in mind.  It is a view of the logical structure.  One layout per
buffer.  

A mark should be part of the logical structure as well changes to the
structure can change the marks.  Buffers request that the local
structure track marks.  


* 05/19/2011 Thursday

** Abiword
I'm looking at the source for Abiword to get a sense of how they do
they're document representation.  There appears to be some good
documentation on their internal data structure here
http://abisource.com/doxygen/

The abiword approach seems to be to represent the entire original text
as a fixed buffer, edits are in a separate buffer of text, and the
document itself as a doubly linked list of pieces which is traversed
to get the form of the document.  Edits are assigned a change record
and undo is implemented as a stack of these change operations which
can be moved down to undo or back up to redo operations.  In a lot of
ways, this is trying to set up persistent data where "changes" are
just represented as additional data added in to the original or new
links being formed.  The formatting is done using pieces which are
text that all have the same formatting and the piece contains a link
to a data structure describing the formatting.  These formatting
structures are kept in another table of formatting objects.  In
looking at the saved file format for abiword, these styles appear in a
table at the beginning and are referenced by name in the spans.  They
have a linked structure (heading 1 inherits from normal which is a
root) which is also represented by name.

The head documentation comments that searching can be a bit slow in
the doubly-linked list and a tree would be preferable.  They also
comment that the internal data structure is not optimized for layout
very well.

** Supporting graphics
I've been trying to figure out how support for graphical jumping can
be added in.  At a bare minimum, I'll want to be able to click to move
the cursor.  This means that the layout object closest by most be
identified and the cursor moved there.  This looks hard with the
data structures I'm considering.  There is no notion of graphical
objects currently, I'd have to write my own clicking algorithm: have a
graphical search tree with coordinates corresponding to objects.  This
would enable me to at least give a layout object, but setting the
point will be difficult.  Unless each layout has a zipper associated
with it which would allow setting the point immediately.  This would
be an interesting idea if the memory overhead of keeping that many
zippers around wasn't too bad.  However, keep in mind that changes to
the logic might invalidate all the zippers requiring re-upping them.
However I currently haven't figured out how to get layout to work save
for rescanning the entire data structure anyway so it may be fine to
do this - as we scan, save a zipper at each spot with the location.  

Actually a better way to do this is during drawing.  If a layout is
just annotated logic, then we zip through the layout associating a
zipper path with a coordinate in graphical space.  However, zippers
don't have a nice way to replicate a path: a zipper is the whole data
structure just with a position in it.  So unless there was a way
around this, I'll have to use zippers for the original logic.  There
may be some synchronization problems with this - don't want logic to
get out of sync anywhere, but maybe I can get around this.

I experimented a little with this in file:trialcode/mapzipper.clj and
it seems that the the memory does increase, but perhaps acceptably.  I
experimented with a modified version of the file 000206B_.xml with 748
measures in it and 3363 notes.  Getting zippers set up for every note
(small bug in my routines led to 3412 notes, forward tag identified as
a note) costs 1.2MB.  There may are better alternatives to this
strategy, but I'll keep it in mind as a nice, naive method.  An
alternative that would cut down a lot would be to use the same measure
zipper for all notes and include just a little bit of extra info that
specifies the part and note.  This hybrid would cut down on memory
required.

** Zippers work differently than expected
Zippers don't quite work the way I thought they did.  Zipping to the
end of a structure gets you stuck: the ending has a circular =zip/next=
and a nil =zip/prev=.  It appears that the way to avoid this is to check
next for =zip/end?=.  Not the way I would have implemented it, but
such is life.

** How to draw a note
Suppose we get to the point in layout where we actually need to decide
the vertical position of a note head.  Information pertinent to this
task is

- Relative coordinates of the staff
- The vertical unit of height - note head height
- Relative octave of the staff
- Which clef the staff being drawn is in
- Pitch to be notated 
- Whether we're transposing for an instrument
- Whether there is a temporary adjustment (like 8va) in effect
- Dictated style like flip the enharmonic

The process of determining the note head position will be
- Asked to draw a concert E5 for a concert Bb trumpet in the score
- The key is concert C which is D for trumpet with 2 sharps
- Determine the instrument transposition 
  - Bb trumpet plays a major 2nd up from concert, so the written note
    becomes an F#, written at the F5 position
  - F# is in the key signature so no accidentals need be added
- Determine if the note has special instructions for drawing
  - Though stored as an F#, the note is requested to be flip its
    enharmonic so it will be written as a Gb instead written at the G5
    position 
  - Assume that the accidental has already been added to the list of layout
    objects 
- From the staff and clef information, compute the top staff line note
  - Treble clef top note is F5 
- Determine the local transposition for things like 8va
  - An 8va is in effect so the staff sounds an octave higher
  - Treble clef top note is F6 
- Compute the number of steps between the note to draw and the top
  staff line note
  - Treble clef F6, drawing at F5, the steps different F6-G5 = 7
- This is the relative vertical position of the written note the
  vertical coordinate increases going down
  - Draw at vertical position 7

This process illustrates a couple things
- We need to be able to access instrument and staff information pretty
  quickly to determine the top staff line
  - Note that there may be a change clef or change of instrument at
    some point so this is not a global property of the staff
  - For ultimate flexibility, this may not even be a property of
    measure but of just some notes.  However, this probably does not
    come up often
  - 8va is a property of notes and may needs to set up somehow 
- The process of determining the written note also determines
  accidentals which adds to the layout objects.  It must be run prior
  to determining horizontal layout.  I'd imagine something like like a
  =(get-layout-objects context note)= which returns a collection of
  objects to be laid out.  The context must carry key signature and so
  forth.  
- Once the top line staff note and target note position are
  determined, vertical position is easy

How do we carry information like current staff/instrument
transposition around efficiently?  My current thoughts go in two
directions
- A tree data structure representation of the entire score rather than
  a linear structure.  Context is looked up by looking at a parent
  node or a series of parent nodes.  This is nice as any note can look
  up its information by traversing some steps up the tree.
  Additionally this paves the way for concurrent processing of the
  measures. Editing operations become much less clear in this context
  though
- Contextual information is built during linear scans of the score,
  changes like time signature, key signature, played instrument, and
  so on are accumulated and altered during the traversal.  This is
  much simpler and what I had originally envisioned for the processing
  but it occurs to me now that this approach does not lend itself to
  concurrent processing of measures.  

** Concurrent processing of measures
I would really like to exploit the concurrency features of clojure to
get multiple threads working on the score for layout.  There is a
quick example of this using some java on the the [[http://clojure.org/concurrent_programming][clojure site]] which
looks like this
#+BEGIN_SRC clojure
(import '(java.util.concurrent Executors))
(defn test-stm [nitems nthreads niters]
  (let [refs  (map ref (replicate nitems 0))
        pool  (Executors/newFixedThreadPool nthreads)
        tasks (map (fn [t]
                      (fn []
                        (dotimes [n niters]
                          (dosync
                            (doseq [r refs]
                              (alter r + 1 t))))))
                   (range nthreads))]
    (doseq [future (.invokeAll pool tasks)]
      (.get future))
    (.shutdown pool)
    (map deref refs)))
 
(test-stm 10 10 10000)
-> (550000 550000 550000 550000 550000 550000 550000 550000 550000 550000)
#+END_SRC
This uses a lazy seq of tasks and a thread pool for concurrency.  The
point is to illustrate the lack of need for locks.  But I'll want to
exploit the task parallelism if possible.  This means avoiding a the
need to propogate information about later parts of the score from
earlier parts: we want to be able to look this up fast.  

** Linear representation still enables parallelism
My fears of crippling parallelism using a sequential data layout are
unfounded.  During the walk, all that is needed is to spawn worker
threads to complete measure layout as we walk through.  Each is passed
the currently accumulated context and sets a reference in the layout
structure at the end.  

** Events
Events such as 8va, dynamics, and rehearsal instructions (rit.) will
come in two flavors.  Measure-attached will have some sort of time
designator such as beat 1, 2+1/4, or the like which specifies it's
desired position.  These will be stored as expressions attached to the
measure.  Note-attached expressions will be stored as attached to the
notes and inherit their horizontal position.  Both of these will also
have their own layout specs such as above or below the staff.

* 05/18/2011 Wednesday

** Layout orientation						      :table:
After some thought, I have begun reconsidering the proper arrangement
of the logical data representation.  The two choices I see right now
are to do a part-wise or measure-wise.  Part-wise has each part as a
list of measures, while measure-wise has each measure contain a list
of parts.  This is essentially the row order or column order argument
for matrices, except that I'll likely be using lists to support faster
insertion.  In both these cases I'm assuming a single point/mark is in
use and that measure insertion is more frequently done accross the
entire score.  If parts are rows and measures columns, then part-wise
(PW) arrangement favors editing single parts while measure-wise (MW)
arrangment favors favors multipart editing.  Below are common
operations and a guess at how fast the data would support it.

|--------------------------------+------+-----+-----+--------------------------------------------|
| Operation                      | Freq |  PW |  MW | Notes                                      |
| Score                          |      | 523 | 629 |                                            |
|--------------------------------+------+-----+-----+--------------------------------------------|
| In-measure move                |   10 |  10 |  10 | Both right/left                            |
| Accross-measure move           |    8 |   9 |   8 | Up right down vs Up right find             |
| Next/prev part                 |    7 |   5 |   9 | PW must walk, MW direct                    |
| In-measure edit                |   10 |  10 |  10 | Both direct                                |
| Accross-measure edit           |    7 |   8 |   7 | Direct for PW, MW must track rect          |
| In-measure multipart edit      |    7 |   4 |   8 | Walk to same measure for PW, direct for MW |
| Accross-measure multipart edit |    5 |   3 |   7 | Ditto for PW, track rect for MW            |
| Synch of aligned measures      |   10 |   5 |   9 | PW must walk, MW is direct                 |
| Measure insertion/deletion     |    7 |   5 |   8 | PW must walk, MW is direct                 |
| Part insertion/deletion        |    4 |   8 |   4 | PW direct, MW must walk to each measure    |
| Jump to measure                |    7 |   3 |   3 | Both must scan                             |
|--------------------------------+------+-----+-----+--------------------------------------------|
#+TBLFM: @2$3=vsum(@II..@III * @II$2..@III$2)::@2$4=vsum(@II..@III * @II$2..@III$2)

This assessment favor MW arrangment as I expect to be doing many more
measure-based operations than part-based.  To boot, there will be many
more measures than parts, so moving between measures in a part would
involve only a step up and then back down the number of parts there
are.

It would also be possible to create a non-hierarchical data structure
for the score which has links between the different elements.  Treated
statically, this might have some advantages for movement as
up/down/left/right could all be included as links for measures.  It
would complicate things quite a lot conceptually though and
potentially wipe out the ability to print the data structure.

** Concurrency
In reading about the concurrency types in Clojure, I'm starting to get
a feel for what would be useful.

*Refs* are good when many threads want to simultaneously access and
change the same global variable which needs to have its state
preserved.  The =alter= command is used to update, =commute= can be
used to allow more concurrency if the operations are commutative, and
=set-ref= is the equivalent of a scheme =set!= which mutates the value
(it is not preferred in clojure).



** Debugging Clojure
Describes some features of swank for debugging I was not aware of
http://hugoduncan.org/post/2010/swank_clojure_gets_a_break_with_the_local_environment.xhtml

Gives a debug REPL that can be inserted.
https://github.com/georgejahad/debug-repl

* 05/17/2011 Tuesday

** Joy of Clojure
Book came today and is full of goodies some of them are below.

** letfn
This is how mutual recursion and internal functions are set up.  The
syntax is like this.
#+BEGIN_SRC clojure
(defn factorial [n]
  (letfn [(fact [i cur]
	    (if (< 0 i)
	      (recur (dec i) (* i cur))
	      cur))]
    (fact n 1)))
#+END_SRC
Mutual recursion can also be set up here as all of the function names
are simultaneously made available to one another.

** Builtin method enumeration
clojure-contrib contains a function =clojure.contrib.repl-utils/show=
which will enumerate the methods available for a java object, both
static (class level) and object level.  This fills the hole I thought
would be there from rhino.

** Built in javadoc
Clojure has a built in javadoc locator:
=clojure.java.javadoc/javadoc= which grabs the java documentation
either locally or remotely.  I have played around with this and got a
much simpler javadoc and bound it to

* 05/16/2011 Monday

** Saving layouts
It would be nice to keep layouts around after a save or a view
change.  This will speed display up a ton.  Example scenario

- User loads a score, score layout is saved so display happens
  immediately
- User switches to view a buffer of a part, layout is generated for it
  causing a delay
- Changes are made to the part, document saved including part layout
  and exits
- User returns and opens score, the switches to same part - part
  layout is already loaded so display happens instantly

There are some prickly issues here as I want to support things like 
- Score in natural pitch
- Score in concert pitch 
- Score in continuous view
- Score in page view 
- Parts in the above
What I envision is keeping a cache of layouts available that can be
examined to get a good start on generating a new layou.  For instance,
switching from natural to concert pitch should not change the
horizontal layout much so the natural pitch layout would be a great
initial value for the concert pitch layout.  Similarly, the page view
can use the continous view as a starting point, immediately beginning
with system layout rather than measure-level.  

This will also need to leverage the layout diff/alignment discussed
below.

Keep in mind that we'll have to deal with a score having multiple
layouts associated with it and then multiple buffers associated with
them all updating the same logical data.  The UI will have to give
clear indications what is associated with what.  For instance,
modifying a part in a buffer should potentially modify score
buffers associated with the part unless the modification involves only
layout details pertaining to the part.

** Layout diff/changed
It would be extremely useful if I could figure out a way to do layout
diffing.  The scenario is:

- A score is loaded
- The user scans to a certain location and runs a command to insert or
  delete notes
- Since the logical representation is changed, the layout must be
  regenerated and reoptimized
- However, there is significant overlap between the existing layout
  and the new logical representation - only a few new logical notes
  are present which will require new layout info
- The intial value of the old layout is usually going to be a good
  starting point for the new layout

It will drastically increase the turn-around time of new layout
optimization if we leverage the old layout info.  This will require
the program to

- Identify which objects in the logical representation already have a
  corresponding layout in the old layout
- Create required new layout objects within the prexisting layout
  (functional/nondestructive so that the old layout can be preserved
  for undo)
- Perform efficient optimization to determine the new layout.  This
  starts by just optimizing the parts of the layout that contain new
  elements, then propagating the changes out if need be (layout
  adjacent measures, vertically aligned maesures, trigger system
  layout if needed)

This will at least require some sort of correspondence between logical
and layout data structures.  I am curious if zippers can help here.

** Layouts as annotations
I worked through some examples of how a layout may just be represented
as an extension of the music logic, the logic annotated with a
=:layout-objects= map which all have a minimum of positions, glyphs,
etc.  While optimizing, the sizes can be determined by asking glyphs
how big they are.  Drawing means traversing the logic, moving the pen
around, and applying drawing instructions for each layout object.
This is actually nice because it means that measure-local coordinate
systems may be employed which would greatly simplify the drawing as
the pen can be translated to the start positions of each measure and
local coordinates can then be used.  Part layouts can also then be
much more directly used from a score buffer to a part buffer.  

By implicitly sharing data accross logic and layout, we'll a fair
amount of space can be saved.  

When changes are made to the score, we need to figure out where they
corresponding layout changes need to happen.  A simple way is to scan
the entire data structure and look for the first difference.  We'd
then need to "recover" by looking for the next correspondence between
old and new logic.  This might be done with measure-level
similarities.  Alternatively, a single N*M sequence alignment might be
useful here to determine the overall correspondence between measures.
But this is very expensive for every insert delete.  Also keep in mind
that the alignment approach is made much more complex by multiple
parts which may be inserted and deleted.



** Layout annotation chains
Treating layouts as an annotation will be greatly simplified by using
a chain of annotations.  For example, a key signature dictates when
sharps and flats need to be displayed.  Deciding whether to add an
accidental as a layout object will requires knowing the current key
signature.  Likewise, knowing when to notify that too many notes are
in a measure requires knowledge of the time signature and how many
notes have been added to the measure thus far.  Both these require
looking backwards to see if key changes have happened.

I might think of encapsulating key/time signature changes in a
context, a general sort of container which holds such information.
A lot of decisions need to be made here as I haven't resolved the
problem of what a context holds - parts or measures?  This is similar
to the horizontal vs. vertical arrangement discussed in the music xml
docs.  I'll want to avoid long search times for such information and
also support global options like view in concert pitch to decide the
actual vertical position notes.

** User loading and slime
Need to have a look at how slime loads up user code so that I can
utilize the same mechanism to get user libraries to load.

* 05/15/2011 Sunday

** Horizontal layout
I was thinking about layout and realized that the first step is simply
to determine the horizontal spacing appropriate for the time signature
and try to use a layout that distributes beats evenly.  This is a good
target and initial value: shifting some notes left/right a slight
amount will be what is used to adjust.  If more room is required for
accidentals, it might be better just to allow more room for all notes
to get equal spacing.  I'll want to look at a lot more music examples
to learn how this is done in practice, particularly for piano music.

In looking at a few charts, enough space should be left between most
notes to accomodate accidentals without changing the spacing much,
only small adjustments.  This falls in line with the idea that the
visual layout should reflect the rhythmic interpretation.

The question is, when and how do we incorporate that information?  The
objective function could have a notion of trying to align notes to
certain horizontal positions.  It will also need to include terms for
overlapping objects and the ideal distances between accidentals and
their associated notes.  

Remember to keep the concerns separate
- Logic to Layout
  - Create visual objects from the logical representation
  - Establish hard constraints and the objective function
- Layout optimization
  - Determine initial values for the objects in measures
  - Optimize within measure positions
    - Use a simple discrete search alg
    - Transformation functions are provided in a list along with the
      objects to which they may be applied
    - These will be things like nudge notes left/right, change arcs of
      slurs, flip stems, adjust incline of beams, widen the measure
    - Objective function measures collisions, deviation from ideal
      note positions, closeness of objects to their targets
    - Search until a timeout occurs
    - Each improvement is committed to a variabl so at the point of
      timing out the best value can be returned      
  - Use this information to determine initial measure and system
    layout in a similar search fashion - determine system/page breaks
    and vertical system arrangement on the page to avoid vertical
    collisions, enforce glued and always-break measures or targetted
    measures per system
  - Take another pass at within-measure layout with the new
    information 
  - Potentially return to system layout and iterate
  - Should use a zero-value to indicate layout is visually as good as
    possible according to the objective function

Note that between the measure-level and system-level layout opt, new
objects may be introduced.  If the system layout decides to break a
system, the first measure may have staff and key/time signature
information added to it.  This will change the layout and objective
function for that measure, potentially creating a big jump in the
objective value.  This means it will be important to normalize in some
fashion so that we don't get oscillatory behavior.  

A simple normalization choice is to divide by the number of objects in
the measure.  Choices must be made there, like do key signatures count
as 1 object or as 1 for each sharp/flat.  That is something we can
experiment with later.

Another difficulty is that the optimization problem changes between
solutions.  For example, layout out a piano part determines that the
RH requires a wider measure than the LH, so we must then reoptimize
the LH, particularly the target horizontal positions of each beat.
For a score with many parts, this generalizes to laying out the other
=N= parts again once the widest has been determined which will be
inefficient.  We could use a very cheap method to determine the widest
measure, lay it out, then lay the others out which would save some
time.

Logging will be important during development to track how optimization
proceeds. 

* 05/13/2011 Friday

** Documentation setup
Got documentation set up at home to use java html files to see API.
| C-c d | Javadoc on current symbol |

** Notes and clefs
Middle C is C4, treble clef is circled around G4 and bass clef around
F3.  See http://en.wikipedia.org/wiki/Clef for more info.

I was looking at the emmentaler font and their notion of the treble
and bass clef symbols is vertically centered at the note that they
tend to center on, G for treble, F for bass.  This will make aligning
them different than I had anticipated previously.  The common time
signature is centered in the middle of its layout as it seems are most
of the note heads.  Will need to experiment with this a little more
moving forward.

** Lilypond internals
http://dvoi.com/files/lilypond/2.12.0/Documentation/user/lilypond-internals/index.html#Top

Lots of info on the objects get inside lilypond. Look at
[[file:~/Downloads/lilypond-2.12.3/lily/simple-spacer-scheme.cc::LY_DEFINE%20ly_solve_spring_rod_problem%20ly%20solve%20spring%20rod%20problem][simple-spacer-scheme.cc]] for a definition of the lilypond spring and
rod problem.  This is a low level part of their approach to solving
object collisions.

** Layouts
I'm going to have to do a several part layout scheme: measure (objects
within a measure) and system (measures within a system).  Note also
that the spacing of notes in a measure should be rhythmically uniform
between parts.  This is an additional constraint I had neglected
previously. 

* 05/12/2011 Thursday
** Leiningen
I installed leiningen at school, needed for slime interaction. Set
=LEIN_HOME= to scratch space for now and put it on the path.  Set up
swank, the slime interface to clojure, with
: lein plugin install swank-clojure 1.3.0
Start it with
: swank-clojure

** Inferior lisp and Slime
Set up run-lisp to work with clojure, just modified the
=inferior-lisp-program= to clj.  Don't have a eval buffer, but can
probably get that.

I got =slime= to run and it contains a ton of useful features, macro
expansion, some debugging, etc.

The basic setup is to start swank from a shell or via my new
=start-swank= then connect using the emacs =slime-connect=.

** Require and renaming
Still trying to get my head around require/use etc but it appears that
the following imports a library with a new name.

#+BEGIN_SRC clojure
(require ['clojure.zip :as 'zip])
#+END_SRC

** Mark behavior
I'll need to consider the behavior of marks very carefully: they are
good until the data structure is modified, then using zipper as mark
will no longer match the current state.  Potential solutions
- Search for proper position
- Update marks as score is updated
- Invalidate marks

[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Overview-of-Markers.html#Overview-of-Markers][Looking at how emacs does this gives]]:
#+BEGIN_QUOTE
Insertion and deletion in a buffer must check all the markers and
relocate them if necessary. This slows processing in a buffer with a
large number of markers.
#+END_QUOTE

So, there isn't as elegant of a solution as I thought.  There are a
ton of functions associated with insertion, but it boils down to
functions in the emacs source in src/insdel.c which, on each
insertion, iterates through the marks and updates their actual
position to reflect the new state of the buffer.  I could replicate
this for a zipper structure, but I'd to think of how to update paths
effectively.  Also, this may not be the best way to update with the
additional information available in a zipper.

This is actually much trickier than I originally thought and concerns
the mark as well as other markers.  Making updates to the data
structure in a functional way will mean the data structure pointed to
by the mark becomes invalid entirely: the score datastructure will
have changed.  This will require some sort of update to get the mark
rectified. 

** Point seems to work
I have been playing with the zipper representation of points in
file:trialcode/notes.clj and it seems to work fairly well.  The timing
seems a bit unpredictable, the first few iterations of the test code
seem to take a while longer than subsequent approaches.  At any rate,
this is viable and something that I'll probably use as a first pass.

** Logical and layout
To facilitate editing pieces, we'll want to use some sort of link
between the logical and layout representations of the music.  When the
logical structure changes, the corresponding piece of layout will also
need to change.

If we have a monolithic data structure for the score, this will
prevent any issues with 

** Record and defrecord
Records are apparently a more efficient way to implement object-like
maps.  =defrecord= sets one up, but to include functions, one must
define a protocol.

#+BEGIN_SRC clojure
(defrecord note [len pitch])		;Simple record
(def n (new note :whole 'a))		;Construct a note
(def n (note. :whole 'a))		;Alternate constructor notation
(:len n)				;Acces len
(:pitch n)				;Acces pitch
;; Full map interface to create new, note it's function though so must
;; save the modification somehow
(assoc n :staccato true)
;A protocol, methods, takes object as first arg
(defprotocol P (dur [this]))		

(defrecord note [len pitch]		;A record implementing the protocol
  P
  (dur [this] (len-dur len)))
#+END_SRC

** .emacs update
Need to get code for org-mode examples into my school .emacs.

* 05/11/2011 Wednesday

** Undefine with ns-unmap
: (ns-unmap *ns* 'mysym)

** Care with load vs load-file
Most of the time I should be using =load-file= as =load= appears to
note reload changed files, just reloads compiled code which does not
reflect source changes.

** Zipper and location
I've started studying the zipper, an augmentation for data structures
(like lists and trees) that allows a location to be kept and edits to
be made in an efficient, funcitonal manner.  This ties to the my
earlier ideas on using functional data structures to avoid the need to
implement undo for stateful objects.

http://clojure.blip.tv/file/4503162/
This video mentions use of zippers to do document editing storing the
state as a zipper allowing easy undo/redo.

Zippers also may give a great way to store marks in a marklist.  A
zipper is a location and a datastructure and can be stored.  However,
since the present state of the datastructure may be different, this
may not work the way that I hope.

Note that the zipper is apparently a generalization of a *gap buffer*
datastructure which is what is used in emacs to represent buffers.

** References, Agents, Atoms
Trying to read through the clojure docs on these three to get a sense
of what is possible.  They will be essential for doing asynchronous
updates of the display as a data structure changes.  Agents will
probably be a good idea for most data like the score, the point and
mark, the layout, as =send= can be used to update them with commands
and =add-watch= can be used to implement updating without needing to
signal it explicitly.  There are also facilities to validate agent
state which may be of use.

** Igor Engraver
I was poking around a lisp site and saw Igor Engraver mentioned as an
application employing lisp.  This is a fairly full-featured notation
software worth a look, though it seems to have fallen off development.

* 05/09/2011 Monday

** Feta vs Emmentaler
Looks like lilypond uses the following fonts

| feta       | Type-1 .pfb | notation, some text |
| parmesan   | Type-1 .pfb | old-style notation  |
| emmentaler | OpenType    | both fonts packaged |

I'll want to use the emmentaler font according to discussion of names
and external resources [[http://lists.gnu.org/archive/html/lilypond-devel/2009-05/msg00222.html][here]].

** Font Types
There are 3 main types of fonts: Type-1 from adobe, TrueType form M$,
and OpenType which was collaborative but it appears to be more a
descendant of TrueType.  All of then can be manipulated with
=fontforge= (installed now) to view and get character sets.

According to the display it gives, each of the glyphs in the font has
a unicode code and some sort of common name.  Haven't been able to
figure out how to access the glyphs based on common name yet, but
will be able to use the unicode glyphs.

** Java Font Handling
It looks like java 1.6 handles OpenType, emmanteler, just fine, so
I'll be using that for preliminary work.  Just treat it like a
truetype font for the =creatFont()= call flag.  Fonts must be created,
the graphics object set to the font, then the string drawn.  When
creating fonts, a static method is used and a new font must be derived
from it to get a different size.

Some code to demonstrate this is in [[file:trialcode/fonts.clj::import%20java%20io%20File%20java%20awt%20Font%20java%20awt%20RenderingHints][fonts.clj]].

** Scrolling
[[http://download.oracle.com/javase/tutorial/uiswing/components/scrollpane.html][This link]] gives some information on the use of scrolling panes in
java.  It is fairly low level, but may be worth a look, particularly
the circle example as it also overviews packing and mouse events
briefly. 

Have a look at the [[http://www.manageability.org/blog/stuff/open-source-structured-graphics-libraries-in-java][libraries listed here]] for some leads on how to make
graphics drawing a little easier in java.

** Git Commands
I have git set up right now so that emacs works reasonably well with
it.  The following must be run from a shell though
| git push origin master | Commit a change to the github repo |
| git pull origin master | Pull changes from github repo      |

* 05/06/2011 Friday

** Design Thoughts
Reviewed my design doc on the models required to make meteo run.  I
had laid this out into three basic categories.

- Music Model: the logical data structure which represents the
  elements that can be edited and manipulated by the user.  These are
  staves, notes, lyrics, etc.
- Constraint model: the logical elements are parsed and additional
  objects are created, for instance accidentals and key/time
  signatures at the beginnings of systems.  These are all items that
  appear in the layout model but do not have coordinates assigned.  In
  addition, constraints on the positions of objects wrt one another
  are given.
- Layout mode: the result of applying the layout optimizer to the
  constraint model.  This has the objects in the constraint model with
  coordinates assigned to them.

The above breakdown does not decide things like when to break
systems.  This is a little prickly because 

1. Deciding a priori when to break constrains the optimizer a lot
2. Allowing the optimizer to decide when to break means new objects
   (staff/key signature) get introduced during optimization which
   could have bad effects.

I'll need to think a little more about how to do this properly.

** Clojure and classpath
Been reading about clojure and java's classpath and things are not
encouraging.  Ideally I'd like users to be able to easily load their
own code from wherever, but it appears that this is greatly impeded by
the classpath.  Classpath is not meant to be changed at runtime and it
seems clojure will only let stuff be loaded using =load= if it is in
the classpath.  This is slightly bad as there is no sane way to change
or add or modify the classpath.  This might not be too bad as I'll
probably just want to implement my own load which simply reads in
clojure sources and evaluates them according to a user-defined 

** Github
Set up git and github so that I can get code too and from school/home.
This does not look like it will be too tough to work with especially
with the emacs version control front-end.

** Reflection warnings
I have been experimenting a bit with trying to bind
=*warn-on-reflection*= to only affect certain codes, but this does not
appear to be working properly.  Part of this is the lexical scoping of
Clojure, which means definitions don't get carried through, but the
real problem is that these warnings are compile time.  That means that
the compiler is the thing that is looking at for the symbol and I
can't hack into it.  This is one time when dynamic scope might
actually be pretty useful, but oh well.  I can get around it with a
little bit of hackery.

** Clojure tools
Leiningen is a project management tool which is supposed to facilitate
java export.  Lancelot is a library builder.  Maven is Apache
software, project management.  It appears leiningen depends on these
other two for various things.

* 05/05/2011 Thursday

** Column averages in org-mode tables
Use a formula like this to get a column average in an org-table
| C-u C-c =      | Edit formula in cell             |
| vmean(@1..@14) | Mean of row 1-14, current column |

** Clojure and Reflection
Turn on reflection warnings doing
#+BEGIN_SRC clojure
(set! *warn-on-reflection* true)
#+END_SRC
This turns out to have a *huge* impact on the performance of java
calls using proxies.  If the type of the proxy cannot be directly
inferred, it will use language reflection which is much slower.  With
type hints, the calls become much faster.  

** Type hints in Clojure
Use the notation
#+BEGIN_SRC clojure
[^my-type my-var ^my-type2 my-var2]
(defn draw [^java.awt.Graphics2D g2d] ...
#+END_SRC
to indicate the types java objects.  Note the =^type= notation This
does not work for primitive types.  Annotations give the compiler
enough info to get the right type and make appropriate calls without
using heavy reflection which can greatly speed code.  Annotations
appears to carry through macros as expected: types from outside the
macro carry inside.  In some cases, the x For primitive types, use
#+BEGIN_SRC clojure
(int (/ width 2)) (double (/ height 2))
#+END_SRC
to coerce them 

** Clojure is Fast
Fractal Test
| Depth | Ringo | RingoMod | Clojure | Clojure2 |
|-------+-------+----------+---------+----------|
|    10 |    70 |       35 |     167 |       12 |
|    13 |   211 |      167 |     776 |       63 |
|    16 |  1110 |      890 |    5078 |      211 |

10000 * 2 drawLines()
|          | Time |
| Ringo    |  181 |
| Clojure  |  762 |
| Clojure2 |   50 |

The Clojure2 is an updated version of the code which gives type hints,
very limited code changes.  It is very fast, faster than the Ringo
version.  Reflection was hurting performance badly and letting the
compiler know to expect a Graphics2D object and casting certain
arguments to ints allowed calls to be resolved exactly.  The
translate() method of Graphics2D has both an int and double version
which could not be resolved without reflection.  Casting using (int x)
fixed this.

** Undo and Functional Data structures
I was considering how to get undo implemented in Meteo and the
using Clojure would actually make this relatively straightforward as I
could implement everything with functional data structures, i.e. no
mutation.  According to clojure, a lot of its core datastructures are
implemented in a way such that the supposed mutation is a low cost
copy and modify.  Exploiting this would be simple as it would just be
a matter of, when an action is performed, copy the old data structure
onto an undo list and set the resulting data structure to the new
state.  If the data is implemented properly under the hood, this will
not take up too much memory, actions will not require explicit undo
commands (no worries about screwing up state irreparably), and
traversing the undo list is as simple as cycling list elements.

** Clojure and memory
It appears to be a big difference between implementations of java.
The version I'm using on the laptop is the open java, 32-bit
: phaedrus [meteo]% java -version
: java version "1.6.0_20"
: OpenJDK Runtime Environment (IcedTea6 1.9.7) (6b20-1.9.7-0ubuntu1~10.04.1)
: OpenJDK Client VM (build 19.0-b09, mixed mode, sharing)
while the school machine has a 1.6 version also but appears to be from
sun and is 64-bit
: java version "1.6.0_21"
: Java(TM) SE Runtime Environment (build 1.6.0_21-b06)
: Java HotSpot(TM) 64-Bit Server VM (build 17.0-b16, mixed mode)
The amount of memory just to start the vm and load clojure is very
different on these two versions:
| Home | School |
| 30MB | 77MB   | 
Note sure what the sourece of this huge difference is, but worth
keepin in mind.  Running jabref at school gobbles memory also, 271MB.

* 05/04/2011 Wednesday

** Recursion slow in Clojure
Additional analysis by removing the main drawline() call from the
below benchmark code indicates that it is in fact the recursive calls
that are slowing clojure down badly.  I'm investigating the looping
behavior. 

** Looping slow in Clojure
According to a looping test, clojure also suffers from slow looping
speeds using their (dotimes) construct. 

10000 * 2 drawLines()
|         | Time |
| Ringo   |  181 |
| Clojure |  762 |

Still not looking good for the Lisp.

* 05/04/2011 Wednesday

** Feeling lack of macros in javascript
While playing with how to define a function with built in
documentation, I encountered a relative impasse, mainly a limit of
javascript's self-reference mechanism.  Anyway, this got me on a kick
looking more powerful JVM language alternatives.  The most promising
seemed to be Clojure.

** Clojure explorations
Spent some of today looking at whether Clojure might be a good
language to use. It is a fully featured lisp that is implemented on
the JVM.  Macros, meta information, and java interop are all
provided.  However, this is a full lisp and I will take some real work
to learn it.  Also, there are no tail call optimizations in the JVM so
some hacks must be used to get recursion to work in some cases.

** RingoJS
An updated version of Rhino that appears to offer the newere syntax
and some basic I/O facilities and module system support.  This is a
good place to start as it seems to be actively developed and worth a
look.  

The modulre system can be used like this:
#+BEGIN_SRC espresso
timer=timer=require("ringo/utils/debug").timer;
#+END_SRC
which imports the a single function, timer (which is useful for timing
a function). 

** JavaAdapter
For both Rhino and Ringo, the JavaAdapter constructor is what is used
to get extend classes and inheritances.  For example
#+BEGIN_SRC espresso
pan = new JavaAdapter(javax.swing.JPanel,
  {
    paintComponent:function(g2d){
      g2d.translate( width/2, height/2);
      g2d.rotate(radians(-90));
      draw(g2d);
  }
})
#+END_SRC
implements a subclass of javax.swing.Jpanel with the paintComponent()
method overriden.  Sometimes this can be done with the new, but
JavaAdapter appears to be more reliable as it does not require
specific constructors for the class to be present.

** Benchmark of Fractal Tree, RingoJS vs Clojure
Found a simple fractal tree drawing code for clojure [[http://www.curiousattemptbunny.com/2009/01/simple-clojure-graphics-api.html][here]] and ported
it with just a little trouble.  I varied the complexity of drawing by
varying the depth of the fractals.  This led to quite a performance
disparity between Ringo and Clojure.

| Depth | Ringo | Clojure | RingoMod |
|-------+-------+---------+----------|
|    10 |    70 |     167 |       35 |
|    13 |   211 |     776 |      167 |
|    16 |  1110 |    5078 |      890 |

In both cases, sometimes several redraws were triggered so multiple
drawing events took place.  This will require greate speed from the
drawing implementation.  It seems that Clojure is clearly slower.  The
java interface must be heavier than the Ringo version.  The
modification which led to some speed gains in Ringo simply replaced a
wrapper over the radians function

#+BEGIN_SRC espresso
// Slower
function radians(degrees){return java.lang.Math.toRadians(degrees)}
// Faster
radians = java.lang.Math.toRadians;
#+END_SRC

Neither code appears to be affected much by the size of the drawable
area as doubling the size of the drawable area seemed to have no
effect on run times.

** Dismissing Clojure
The case for clojure is
- Lots of progamming language features built in
- May make development a bit faster as a solo effort
- Might lead to a better over look/feel of code
- Looks/acts more like emacs

The case against
- Java interface speed appears to be an issue, though this could be
  remedied by further study of the proxy construct for extending
  classes
- Will alienate a lot of potential developers by going this route
- Missing the nice javascript/XML syntax for manipulating data
- Tied to JVM as it is not likely that there will be much chance
  Clojure will be available for Qt or Gtk anytime soon

Thought it would be fun to program in Lisp, I'll for now ere on the
side of inclusiveness for the time being and revisit this decision
once things become more apparent.

** Music Wrapper
I may want a simple container-type data structure in my music
implementatation to hold measures and can have a new time signature,
key signature, instrument, or other type of change (perhaps a 1st
ending) which are not necessarily easily represented otherwise.

** Duplets
I'll still need to decide upon a logical representation of duplets.
This will be a bit tricky, but then the whole time signature/note
length thing is tricky.

* 04/27/2011 Wednesday

** Design Decision: Javascript and Rhino
I've decided that I'll be working with Rhino for the initial pass at
Meteo. Here are some notes on the final call.

*** Advantages
- Java as the implementation means garbage collection is always going
  to be there making life a lot easier
- Java has good GUI and drawing capabilities and excellent docs on
  both
- Rhino has a *very* direct connection between javacript and java
  - Classes are exposed and method/properties are enumerable with the
    for..in syntax of java, good for exploration
  - The package system is there making finding classes easy
- Rhino has E4X (see below), direct coding of XML in javascript-like
  syntax 
- Should benefit from the cross-platform nature of java
- Good prep for teaching Java next fall
- Using Rhino gives a very good way to experiment between
  front/back-end code behavior.   If I decide to change back ends,
  only the back end interfaces will have to change
  - Front end - the API that will be officially scriptable, hopefully
    most of the program
  - Back end - where Java comes in to provide file access, drawing,
    and GUI 
- Rhino can compile javascript code to java classes directly,
  potentially improving performance without the need to implement
  logic directly in java.  This is a good analog for byte-compile
  emacs code
- There are some Java sound capabilities that might make it possible
  to quickly incorporate sound output.

*** Disadvantages
- The memory footprint will be perhaps heavier than a lower-level
  implementation like Qt or direct library use. Rhino itself starts
  using about 16.7M.  Loading a single Swing
  (examples/SwingApplication.js) window bumps this to 37.5M.
  Additional windows take about a 0.5MB per call.
- Not going to get Cairo which apparently has good rendering and
  convenience along with performance.
- The drawing may be screwy if the java programs I've used are any
  indication - will have to be careful as I develop
- Javascript's program model and scoping are a lot screwier than Lua's
  which will make it a little weird to use

** E4X
A really cool way of embedding XML in javascript directly.  It looks
like a joy to work with as the datastructure manipulated in a similar
fashion to regular javascript objects.  The Mozilla tutorial is here:
https://developer.mozilla.org/En/E4X/Processing_XML_with_E4X

** Basic objects
I'm going to need to start collecting the basic objects required for
the implementation of meteo.  Things like file access are no provided
by javascript directly.  As a first pass, I'll likely want to use
javascript to create the notion of a class which just wraps some java
functionality.  As needed, we can convert these to java classes.  All
of this stuff will be on the back end side with a javascript face.
Thus, if down the line I change to a different back end, Qt or web,
then we'll just need to change the back end code out and the front end
should be relatively stable.

** javac - compiling with jars
A few commands to keep in mind when dealing with jars and java
compilation.

| js.jar            | Java notion of library/archive, this one has Rhino in it                 |
| CLASSPATH         | Env var, semi-colon separated list of directories and jars for libraryes |
| -cp or -classpath | Option to javac which allows setting classpth                            |
| javac -cp js.jar  | Compile with Rhino's library included                                    |
| jar tf js.jar     | List contents of a jar file                                              |

** Working with MusicXml and E4X
The model laid out by musicxml is going to be a pain to work with
directly because it has a lot of redundant information even in the
simplest setups.  For instance, there is both a duration (e.g. 1,2,3)
and type (e.g. half/whole) to describe note length.  This will be a
pain to work with.

I will need to start pouring over the musicxml specs to understand
what a lot of the seemingly superfluous tags might be.
http://www.recordare.com/musicxml/tutorial

** Notes on MusicXML
I am making a study of musicxml to see it's model for music data.
Made it through about page 34 of the musicxml tutorial to learn about
some of its features.  Notes are below

*** Part vs. Time 
There are apparently two XML formats, score-partwise and
score-timewise which differ in whether they arrange by parts or
time/measures.  That is, the first has measures inside parts while the
latter has parts inside measures.

*** ~<attributes>~
Within a part (or measure) the ~<attributes>~ tag shows up firts.  This
is where time and key information get put.

Follows MIDI in that there are ~<divisions>~ which are the number of
pulses per quarter note(?)  which is apparently the shortest length
allowable for a note.  A division of 24 allows sixteenth or triplet
rhythms. The time signature is specified in a more straight-forward
fashion with
#+BEGIN_SRC xml
<time symbol="common">
  <beats>4</beats>
  <beat-type>4</beat-type>
</time>
#+END_SRC
for common 4/4 time.  See later discussion of note durations for more
on this.

Key signature is specified with
#+BEGIN_SRC xml
<key>
<fifths>-3</fifths>
<mode>minor</mode>
</key>
#+END_SRC
for F minor fairly easy to follow.

Multiple staves can be specified with ~<staves>~ for a particular part.

Clef is specified here with ~<clef>~.  This has both a ~<sign>~ (G for
treble, F for bass) and ~<line>~ for where the clef lives (2 for treble,
4 for bass).  For multiple staves, multiple clefs must appear with a
number="1" attribute for which staff the clef corresponds to.
Wikipedia has a good article on clef names, but will probably not need
to worry too much about this, just get bass, treble, and alto later.

This is also where transposition information is stored.  There are
fields for both playing transposition and writing transposition,
diatonic and chromatic.  Pay special attention to transposition
information - when doing a layout, showing the score layout is one
thing, possibly done in either concert or transposed key, but the part
layout will need to be done in transposed layout.  If we are going to
model the parts effectively in one data structure, we'll need to track
layout annotations in several contexts.

*** ~<note>~
Notes are contained in ~<note>~ tags.

~<pitch>~ gives pitch information, inside it are: ~<step>~ gives the
line - A,B,..,G, ~<alter>~ the flat/sharp (+/-2 for double sharp/flat),
~<octave>~ the octave of the note, 4 for middle C.  Note that the
enharmonic is specified for display, but this may not be the best
representation for comutation.

~<duration>~ gives number of pulses, quarter note pulses are from
~<divisions>~ in attributes.  There is also a ~<type>~ element which
specifies quarter, half, etc.  This is to enable display of one type
versus playback in a swing style or other inferred rhythmic
variation.  This is actually sort of prickly issue which I'll want to
attend to.  My representation will need to deal with these issues as
well, but playback duration can be a different issue.

In addition to this, there is ~<time-modification>~ for duplet/triplet
rhythms.  From the example
#+BEGIN_SRC xml
<time-modification>
  <actual-notes>3</actual-notes>
  <normal-notes>2</normal-notes
</time-modification>
#+END_SRC
gives a standard triplet, but this is dependent upon the context.
Additionally, to specify something like a quarter-eighth triplet, more
convolutions are needed:
#+BEGIN_SRC xml
<type>quarter</type>
<time-modification>
  <actual-notes>3</actual-notes>
  <normal-notes>2</normal-notes>
  <normal-type>eighth</normal-type>
</time-modification>
#+END_SRC

This follows the model that I was looking at where we have playback
and display information separate, but it looks a difficult to parse
through.  Need to strive for something uniform and elegant here.  Keep
in mind we'll want to generalize to potentially any duplet value (5/1,
5/2).  This will be difficult.  Recall lilypond's approach was
something like setting up a temporary time context.

A rest is given with ~<rest/>~ and a ~<duration>~ is specified.

A tie is specified within a note, ~<tie type="start">~ and ~<tie
type="stop">~, in reverse order for notes that are both.  There does
not appear to be a notion of a "target" for a tie which is
troublesome. 

Note stems are specified with ~<stem>~ and can be either up or down, not
sure if it is required element.

Note beams are specified with
#+BEGIN_SRC xml
<beam number="1">begin</beam>
#+END_SRC

where the number attribute determines the "level", 1 for eighth, 2 for
sixteenth, etc.  The text in the element is one of begin, continue,
end, forward hook, and backward hook.  These will probably be optional
attributes in my note model.  There will be some global options
defining how eighth and lower beams are treated with annotations
similar to this to further specify rendering.


A ~<staff>~ can also be specified which indicates which staff the note
is targetted to land on.  This enables cross staff notation but will
be somewhat difficult to translate to internal data structure
representations.

Lyrics are included in a ~<note>~ with ~<lyric>~, but I will ignore those for now.

*** Chords and Voices
Also part of ~<note>~ are some additional features for logical grouping.

~<voice>1</voice>~ is a logical device used to indicate a note should be
grouped with some other notes.  In the examples given, this seems a
substitute for either layers or chords.

A chord is specified by using a ~<chord/>~ tag within a note.  This
"backs up" the counting mechanism normally specifying a subsequent
time position for a note.  This is a little gross as the notes in a
chord must all agree on the duration or the counting mechanism will
become screwy.  For internal representation, I'll probably want to use
a chord element with a single duration and potentially multiple
pitches.  Multiple voices will be used to do differing durations. 

*** Forward and Backup
Within a measure, the position in time can be further manipulated with
~<forward>~ and ~<backup>~ which both take a duration element.  This adds
a order-dependent aspect to musicxml which is a bit gross.  The XML is
a recipe, but must be followed in order to accurately output the
elements. 

In terms of my own representation, this is not desirable.  What is
probably a better idea is to use some sort of absolute offset from the
beginning of the measure to represent a note/chord's timing
information.  A data structure that contains the notes/chords in order
of offset from the beginning will facilitate display and traversal.

Granted, I will probably want to be able to rely on parts appearing in
order in the datastructure representing the score, but the temporal
aspect of the musicxml layout mechanism looks very difficult to deal
with. 

** Design of layers/chords
I'll probably start my internal representation in XML and follow the
model that I recall from Finale.  This was the ability to specify
chords, multiple notes linked together with the same duration, and
layers which represent independent lines in a staff.  Single notes are
just one-note chords.  This will mean the hierarchy is something like

: part -> staff -> measure -> layer -> chord -> notes

Bulk operations will be a little hard to logically organize with
layers, but can implement options here: use keystrokes to quickly
switch between layers, copy/paste works on all layers by default, can
specify individual layers if needed.

** Point/Mark behavior
When we get the interactive part, the point will represent a position
between two of absolute positions in a measure as will the mark.
Point and mark may also need to contain part/staff information so that
multiple staves can be copied and pasted, transposed, etc.

** Capella
Recordare, the company partly responsible for the musicxml standard,
has their own software, capella, which might be worth a look as they
claim that the pc keyboard is used for editing.

* 04/22/2011 Friday

Rhino is really looking attractive as a platform.  It has exactly what
I am interested in for development: REPL with full access to the whole
Java platform through javascript.  It's as simple as running a jar
from java to get started and loading some scripts.  Been looking and
messing with their swing application and it appears to have full
introspection of java objects through the "for(v in obj){}" syntax.
Awesome.

The next step is going to be to explore a little drawing with it using
Java2D, need to find a complete example which allows me to specify a
drawing area to play with: this may be a start
http://www.cs.ucl.ac.uk/teaching/D0a1/additionalnotes/SimpleDrawing.html

Already able to do this with something akin to

: f = new frame()
: g = f.getGraphics()
: g.drawLine(0,0,300,300) ;

Easy as pie.  There even prototypes avaible:

: js> g.drawString
: function drawString() {/*
: void drawString(java.lang.String,int,int)
: void drawString(java.lang.String,float,float)
: void drawString(java.text.AttributedCharacterIterator,int,int)
: void drawString(java.text.AttributedCharacterIterator,float,float)
: */}
* 04/18/2011 Monday

** Reflection in javascript
It appears that reflection works fine in Javascript, just use "this"
in the global context to refer to a global symbol.

qs> for(var v in this){ print(v); print(this[v])}

Unfortunately in qtscript, this does not display the globals I had
hoped: Array, String, etc. are all still hidden.

* 04/03/2011 Sunday

Successful compile of libqtlua.  Did this simply by eliminating the Qt
version checks in the appropriate files.  Everything appears to work
correctly, including the qtlua shell.  

qtlua shell has some peculiarities, print() seems to include quotes,
but that is only a small issue.  Have been looking at how it works on
the C++ side to see if I can get an idea of how to integrate.

[[file:packages/libqtlua-1.2/tools/qtlua/qtlua.cc::][Source for qtlua.]] 

Looking at the examples in the console directory, particularly
[[file:packages/libqtlua-1.2/examples/cpp/console/console_fcn.cc::][console_fcn]] to get an idea of how lua and Qt talk to one another.  To
add a function, implement an instance of QtLua::Function and register
it with the Lua state.

There is an interesting illustration of a tree view of the namespace
in Lua which appears more powerful than the whos() function which I
typically implement.  It is [[file:packages/libqtlua-1.2/examples/cpp/mvc/tabletreeview.cc][here.]]

There is an added builtin function, each(), that luaqt adds which
works just like the pairs() function for iterating over tables.

* 03/30/2011 Wednesday

Successful install of Qt 4.7 SDK, adjusted path of shell to reflect
this.

Working on the qscript interpreter example in file:~/devel/qscript.  

Javascript does not provide direct access to the global object
(e.g. the global namespace) but this was easy to add on the C++ (right
now assigned to "G").

Right now my biggest gripe is that for javascript objects, there all
the properties are not listed.  For example, creating an a array with

var a=new Array(1,2,3)

then trying to enumerate the properties with 

for(var v in a){print(v)}

gives only 0,1,2.  This will be a problem as it will make it
impossible to keep proper track of what kind of thing the object is, a
major disadvantage as compred to Lua's tables which are for more
transparent.  Unless there is a way around this, I'm not sure that
javascript will be a good choice.

However, getting libqtlua to compile has not succeeded yet.

* Old
** Framework

When I get to writing the music software, the available framework
could probably go something like this.

- Ocaml as the implementaton langauge.
- Scheme as the extension language, several options for interpreter in
  ocaml 
  - Schoca http://sourceforge.net/projects/chesslib/, older - buggy
  - Ocs http://will.iki.fi/software/ocs/, newer, can't get the
    r5rs-test to run from schoca
  - http://www.complang.tuwien.ac.at/schani/oldstuff/index.html#schemeinocaml
- Ocaml bindings to Cairo rendering engine
  http://www.cairographics.org/cairo-ocaml/
- Bindings appear to require lablgtk


Some other related programs

- SpiderCaml is a javascript interpreter for ocaml.  Not sure about
  how to get bindings.
  http://alain.frisch.fr/soft.html

- This is a good article on design of emacs-like text editors
  http://www.finseth.com/craft/

I was thinking about the nature of applications and how their UI
should be designed to suit it.  A text editor is designed for input of
text.  Primary keystrokes should pertain to this.  I think emacs
accomplishes this reasonably well with its decision to assign most of
the standard keys to self-insertion, secondary commands (motion) to
single-key chords, and more complex commands (find-file) to multi-key
chords.  Vim goes the other route and explicitly establishes two modes
of operation for this purpose, but being well practiced at emacs I
like being able to make quick edits to text on the fly without having
to switch modes.  Conkeror makes a good decision that the point of a
web browser is to move around in web pages so most key strokes should
function for that purpose.  Firefox reserves most single key strokes
for typing as it does not adjust the key map to different situations
(text box, address bar, body of web page), at least not over much.

** Other Tools of interest
*** Canonrus
Music notation program, allows ruby/python scripting interface
http://canorus.berlios.de

*** Snd
waveform analyzer, allows scheme, ruby, and forth scripting.
Interface is intentionally similar to emacs
https://ccrma.stanford.edu/software/snd/snd/snd.html

*** Cameleon
Ocaml text editor which has a lot of emacs-like features already built


*** Gsharp
http://common-lisp.net/project/gsharp/

This is a common lisp-based notation program which uses a McCLIM (an
open source implementation of the Common Lisp Interface Manager
specification).  It looks like a great start to the ideas that I
have. 

There are a lot of basic music stuff missing from it which are
described in the ending (page 73) of the PS manual.  

There is a discussion of the algorithm used for beaming in the manual,
appendix B and discussion of placement of accidentals in appendix C.

*** Seed
http://live.gnome.org/Seed

A GTK scripting implementation of javascript, allows dynamic binding
to new GTK objects through some sort of introspection deal.

*** A potentially good combination
Steal the UI of Cameleon for managament, enable note buffers usinge
Cairo's ocaml interface (pretty good, in ~/packages) and run ocs as
the embedded extension language.  I would probably need to transfer a
a lot of control from Cameleon2 

*** PXP
An interesting XML library for ocaml which allows automatic parsing
and also mirroring the XML classes as other classes with additional
functionality. 

*** Wikifonia
A great place to search for free lead sheets

*** Lilypond
It looks like there are a lot of functions in
lilypond/scm/output-ps.scm which create postscript drawing
instructions for various objects.  So at some point in the lilypond
executable, it must jump into these functions to produce the
postscript. 

Check out the developer resources on Lilypond's site as this is where
the regression tests are stored, bibliographies on engraving, and
documentation of the code.

The hierarchy of their data appears to be a series of nested contexts:
Score > Staff > Voice.  Each context has associated with it Engravers
for different musical elements.  According to essay, the Engravers
need to have some awareness of of one another but are somewhat
independent.  

I'm still trying to disect the various source files and how they relate
to one another: for instance Accidental_interface, Accidental_entry,
Accidental_engraver, Accidental_placement.  It may be sort of lost
cause to understand their approach as it is very complex.

** Software Design
Spent some time reading Steve Yegge's post on properties of good
software.  The idea of a "living" piece of software is a good thing to
abide by, that restarting is more or less equivalet to killing the
program and should be avoided at all costs.  Also, the division
between "hardware" which are the immutable pieces of the system and
"software" which are the pieces which can be changed, reprogrammed,
customized is good.  He goes so far as to term statically typed
languges (haskell, ml) end up defining hardware.  This is not bad, but
it is good to recognize that it is the case.  Extending the
functionality of a running system is not really possible in Ocaml
necessitating the use of a scripting language.  

In essence, most systems are based on C.  Scheme and lua are written
in C for the most part.  Therefore, interfacing them to libraries
written in C is not so bad.  If we were going to start from scheme or
lua directly, you would code primitives (hardware) in C and build the
system on top of that.  Glue between the parts becomes C.  One must
worry about memory management cooperating between the base language
(C), interpreter (scheme/lua) and libraries the in these cases.  If
the hooks are set up well, there is not need to worry.  If not, then
you're hosed.

I'm looking at the implementation language being Ocaml.  That would
mean that I'd have to follow one of two routes:

- Interface the scripting language with Ocaml with C as the glue.
  There would be a lot of ugliness exposing Ocaml functions as
  exported C functions: the API for this is there but looks gross.
  Getting respective memory managers to cooperate would probably also
  be a mess.

- Contain the interpreter within Ocaml so that the there is no glue:
  exporting core functions from Ocaml to the interpreted language is
  straightforward and any library bindings are given to the extension
  language as functions from Ocaml.  The advantage here gluing is a
  cinch and there is only one memory manager.  The disadvantage is the
  need to write an interpreter.  Another potentially awful issue is
  getting the types to cooperate betwee the host (ocaml) and embedded
  (lua/scheme) and language.  In looking at ocs's approach to this,
  it's not bad as we're only dealing with the base types of scheme
  which are limited.  However, building a notation application will
  employ a wealth of types which will require a lot of new additions
  to the type system.  According to the Module Mania paper about
  combining Lua and Ocaml, this was not easy, their strategy used a
  ton of functors which is not really a direction I want to go in,
  because it'd be hard for me and hard for anyone else that came
  along.

The type difficulty in ocaml should not be underestimated.  The
ability of straight lua to seamlessly handle a lot of different data
types is cool even if the glue to put it together looks bad.

One thing to bear in mind is the model of emacs.  Hardly anyone
updates primitives in order to extend the functionality of emacs.
Everything is done at the scripting language level.  This makes it
imperative to have the wealth of the types available to the scripting
interface.  Access to internal data will be particulaly important for
designing layout algorithms which are pluggable and modifiable.  This
means a lot of types will need to be available to the scripting
language.  

In scheme this will mean modifying the scheme implementation to make
the types understandable to scheme system.  This is similar to the
approach of emacs in which there exist the fundamental lisp types in
addition to the emacs types (buffers, mark, region, etc).  

It is harder for me to see exactly how this would work with Lua.  The
language is not really intended for massive type extension.  Rather,
you're supposed to be able to do it with the userdata.  I have been
looking at this in Lua and the first thing that has struck me is that
this is where the typing system breaks in C and becomes onerous in
Ocaml.  As in the scheme case, in order to communicate types between
implementation and extension language, the extension language types
must be well defined in the implementation language.  I don't think
this would be too bad though as the fundamental types are not too bad
and can be encapsulated with a polymorphic type:

type userdata = 
  MusicBuffer of musicbuffer | TextBuffer of textbuffer |
  MusicRegion of musicregion | MusicPosition of muspos | etc.

These will not change too much once established in the hardware.  On
the Lua side, there are a number of ways manage the identification of
the types of data.  The easiest is just to associate a metatable with
the .type field in it when installing the fundamental types.  

There appears to be a wealth of ways to structure packages in Lua,
basically because it has such loose semantics for defining things.
As long as I use reasonably regular means for setting up the packages
and metatables, this should not be too bad.

I would like to be able to do real package managment with managed
namespaces in the embedded language.  Scheme, even with R5RS macros,
does not really allow for this to happen to due to limitations in the
macro system.  Lua is much mor appropriate for this but it means I'd
have to roll my own interpreter.

** Interpreters

There is a paper by Nick Benton, "Embedded Interpreters," which
discusses some of the issues for gluing implementation and object
language together.  His implementation language is SML so there are
probably some good tricks here.

Norman Ramsey wrote a number of papers on embedding Lua in Ocaml.
http://www.cs.tufts.edu/~nr/


** Two Libraries
There are essentially then two libraries that I would need to create
which interfaced with Lua.  

The first, and most important, is a library for doing layout of some
internal representation of music.  Given a "region" of interest and
perhaps start and stop constraints, it would attempt to lay the
musical elements out on a display.  For the time being, I would limit
this to one staff but ultimately it would be nice to do multiple
staves for score printing.  The library should be repluggable in that
the host language provides primitives that may take embedded language
elements as callbacks to do various things.

The second library is a basic editor/gui library which people can plug
things into.  Again, primitives in a host language with hooks back
into the embedded language.

** An implementation of Lua
It would have to definitely have
- Tables
- Metatables
- Error handling

Could probably skip these on the first pass
- Coroutines

Perhaps a better way of going about this would be just to start with
the C implementation of Lua and write some C primitives to test out
the layout ideas first.  This would allow me to get a feel for what is
required.  We could do this sans gui for the moment just running in
the Lua interpreter.  It would also ecourage the development
of the notation layout library as a modular piece of software and let
me test some ideas to begin with.  Valgrind will help with the
inevitable memory problems.  Writing in C may also help me to utilize
some pre-existing code from lilypond.

** Layout Problem

I spent some time looking at the Lilypond website and reading there
code.  The essay was particularly interesting as it discussed the
difficulties of actually laying out the notes once you've figured out
the necessary notation.  The way it looks is that an initial placement
is made and then lots of adjustments are tried as a way of trying to
improve an objective function gauging the visual appeal of the music.
Sound familiar?  

This seems like a something that would be incredibly intersting to
start woring on.  The objective function should be pluggable: can
alter it to something else.  The way to get online layout vs. batch
processing as in Lilypond is to have ensure the initial layout is
produced fast and the optimizer can be run at varying levels of
tolerance.  I envision the optimization process as being discrete so
we're probably best off starting with simple search strategies which
check at each step how much time has elapsed and bale out with the
best solution after reaching the maximum.

There is the issue of representation and measure of the objective
function as the objects of interest are graphical and it will probably
take some effort to measure certain things like clashes of slurs with
notes.  Also merely deciding which things should be included in the
merit function could be sort of difficult at first though if I can
find the Lilypond decisions it will probably be inspirational.
Determining which functions may be used to adjust parameters may also
be onerous.

To enable hackability of these functions, they need to be reasonably
accessible from the embedded language (scheme/lua).  This will allow a
lot of things to be tried in a scriptable fashion and then ultimately
translated into the underlying implementation language (software \to
hardware transition).

** The Model

Lilypond makes an interesting point in that the notion of a
hierarchical view of notation has some limitations, especially for
certain types of music such as piano pieces (cross staff beaming,
slurring) and modern music.

The question then becomes, how do you actually implement a model-view
paradigm that is managable?  Beaming is a good place to start.  Where
is the decision actually made to beam two notes?  In Lilypond this can
be adjusted manually using brackets so that beams run over rests (done
in Finale also).  This seems simply implemented: beams have a start
and stop element to which they are attached and follow suit.  Same
with slurs.  What about going accross a staff though?  In the sense of
a note belonging to a staff, this sort of breaks down some.

In looking at the regression tests on cross staff beaming, it seems
that the lilypond source has explicit notations for changing the staff
to which a note belongs.  They can also change the direction of the
beam explicitly with commands.  Thus the notation in source is a bit
kludgy, but from the standpoint of interpreting the input, it's not
too bad: just adjust the pointer to the note's parent staff at the
before determining position.  Everything else falls into place then:
stems, beams, and slurs all happen after that.

The question is, how does one implement this in a sensible way for an
interactive, keyboard driven GUI?  No answers at this time.

** Haskell?

There are some interesting bindings available for Haskell which might
make it fun to try programming.  There is a good looking Lua interface
and a GTK binding with some Cairo support, though it does not look
like PDF support is present at this point.

** Plan
The thing to do is to start small.  The first goal will simply be to
design a small Ocaml library for rendering notation using Cairo.  I
can worry about GUI and extension languages later, but having a few
basic pieces of soft hardware will be the first step towards
understanding what's going on.  

I'll need to think of how to represent the data.  At first, this can
probably be a compiled Ocaml data structure which will be easy
enough.  I'll need to learn how to use Cairo then according to the
ocaml interface and probably also from reading the C tutorials on it.
This will also force me to start setting up clear boundaries between
drawing functions, music abstractions, and the ultimate user
experience. 

** Representations
The most basic representation is that of the logical musical elements:
staff, clef, notes, slurs, etc.  Call this the logical level.

The next level of representation is the layout representation.  This
is where decisions are made about accidentals that need to appear,
stem directions, beaming.  This is where initial and optimized
positions are chosen and constraints appear.  

The final level is display which is where a layout is converted into a
series of drawing instructions.  There may need to be some glue in
between layout and display as the actual sizes of the elements may not
be available except at the display level.  

Not sure at this point how to do redrawing properly.  The simple way
is, add a new element, completely recompute layout, then redraw ths
screen.  For large scores, this will get taxing quickly.  The first
step to beter efficiency is recompute layout only for those parts that
need it.  If we are working on bar 4 and nothing has changed which
would affect bar 1, there is no need to recompute its layout.  An even
more efficient means would be to then only redraw that part of the
layout that has changed from the previous version.  With proper
constraints, this may be possible by masking or clipping only the part
of the score that needs to be redrawn.  Keep the suggestions on the
Cairo FAQ in mind as to how clipping can either help or hinder
performance.

http://cairographics.org/FAQ/

In thinking about how to get accurate reflections of system breaking
between score and part views, I'll want to attach annotations either
at the measure or staff (group) level of individual staffs to indicate
that when they are being viewed in a reduced setting, there should be
system breaks at the defined positions.  

** Design using Cairo
I played around with some of the ocaml-cairo bindings and found that
drawing from a gtk surface to a pdf surface does not result in very
nice looking stuff.  With that in mind, I'll need to write code that
takes a Cairo drawing object and renders a layout rather than rely on
the cross-surface drawing functionality.  This is a little icky but we
want our PDF output to look nice, right?

In playing with this in the 'cube' example of ocaml-cairo, I was able
to add gtk widgets and get callbacks to work pretty quickly.  That
bodes well for the eventual GUI design.  But first, library layout
stuff. 

In testing, I have figured out that what essentially there needs to be
a 'render' routine which will take a cairo device, do the drawing, and
then finalize the surface.  The device may be a GTK drawable area or a
PDF surface for output.  This keeps the path information so that the
output looks the same between them.

** Threads
Take a look at the Ocaml thread library for potential means of
branching rendering or layout optimization off.

** Glue between Scheme-Ocaml
Designing the library, I should probably start off pretty early
thinking about the scheme representation of the underlying hardware.
It seems that there are some advanced features in slib which include
syntax-case which, if we could get it to run with ocs, it would be
useful for developing packages.

** Working with lablgtk and cairo-caml
- Make sure to include the module lablgtk2.init
- It appears that the gtk widgets must be "shown" before a child cairo
  rendering context is allocated.  It also appears that this context
  must be continually gotten again with Cairo_lablgtk.create.
  According to the gdk-cairo interaction website, this is due to
  double-buffering issues: "Note that due to double-buffering, Cairo
  contexts created in a GTK+ expose event handler cannot be cached and
  reused between different expose events."
  http://library.gnome.org/devel/gdk/stable/gdk-Cairo-Interaction.html
- In the ubuntu package for cairo-caml, there is no support for pango
  so I compiled the source version and extracted the pango parts into
  it's own little packge which I installed using ocamlfind.  It looks
  like this:

: $> cd ~/packages/caio-caml
: $> sudo ocamlfind remove pango-cairo
: $> sudo ocamlfind install pango-cairo *
: $> sudo chmod a+rX -R /usr/lib/ocaml/

** Pango blues
It appears that there is no ability to load new fonts using the pango
interface to ocaml available in lablgtk.  This might not be too bad
because it's not too bad to install fonts in the current ubuntus and
there are a couple options for music fonts, particularly ntedfont from
nted.  For now I will work with this.

Using the ubuntu character map is useful for determining which
character is which.

The following is a python example of how to load a font and use it.
This may be useful should I need to roll some Ocaml-c glue to load
fonts. 
http://cairographics.org/freetypepython/

** Glade
Glade is proving fairly useful for putting together a simple GUI.
There is a tool in lablgtk called lablgladecc2 which compiles the
saved result of a glade project and converts it into an Ocaml module.
This will make testing a lot easier.  

There is one bug however: for text inputs, the circle 'invisible'
text is not parseable by lablgladecc2, just set it default (right
click and select default which is an asterix).

** Lablgtk and drawing_area - redrawing
In order to get redrawing on a redrawing area, the need routine is
well hidden (i.e. not locatable) in the documentation for lablgtk.  It
is done with:
:   GtkBase.Widget.queue_draw (area#as_widget)

I stumbled on it in an explanation of cairo multithreading here:
http://cairographics.org/threaded_animation_with_cairo/
There is some advanced discussion of using alarms for efficient
drawing.

** Linked values
It would be nice if there were a way to use global variables that are
tied to gui elements, it that if the variable is changed, they signal
other objectives of their change to other tied objects.  Smalltalk
style, right?  Not sure how to do this in a simple way.

** Next steps
I have gotten a better understanding of how lablgtk and cairo
function.  I've also kind of figured a few things out about text.  The
next step will be to start getting size information for text using the
Pango interface.  This will allow me to properly place a few objects
on a staff to get a feel for what's involved.

May have to use a transformation matrix in Cairo to do scaling as it
doesn't seem that there is an easy way to set the 'extents' of text
through Pango.

** Switching to Lua
I think I will probably make the switch to developing in pure Lua for
a while to see how it would look to work with the dynamic language.
It appears that there is a mature set of gnome bindings and also a
mature cairo interface.  I need to download and compile the latter
while the former has an ubuntu package.  However, I think the gnome
package is broken, no gtk.so for lua, so I may have to compile for
source. 

The reasons for this switch are that I would like to have a scripting
interface at some point and Lua is a good choice for this according to
everything I've read so far.  It uses the Properties Pattern with its
tables which Steve Yegge and others have lauded in javascript and lisp
(property lists in lisp).  It has a clean syntax and interfacing with
the external libraries should be pretty straightforward.  I also like
the module capabilities which seem simple but flexible (not as
powerful as Ocaml certainly, but what is?).  

I don't want to fall victim to premature optimization by picking Ocaml
as it is a lower level language than Lua so I'll see what comes of
this effort.  For certain almost any C library can be put into Lua
easier than Ocaml.  That may be a big help later. 

** Cairopad
This is another project done by the author of luacairo and it is
excellent.  It provides a live means of testing cairo drawing with
lua.  It gives me just about everything I need to starting developing:
a gui, lot of examples for using cairo with lua, and some great
framework for interfacing lua with C and with wxwidgets for cross
platform gui development.

** Logic of Chords/Lyrics
Treat chords and lyrics as another 'voice' to be added to a particular
part - their display mechanism will be different in that they get put
above/below the staff.  But other than that, they will have their own
keymap for input, objects in them will have not durations and rests,
possible playback, etc.

** QT for GUI
I have started looking at QT as a possible means of doing the GUI part
of the development.  This would be nice as it is cross-platform, more
modern C++ thatn gtk, has mature tools, and is relatively recently
been completely GPL'd.

There is a built-in QTscript which is a ECMAscript (javascript)
implementation which would be great for extensibility.  

There is also a qt-lua project but does not seem to have updated to
the most recent version of QT (4.6, last working version was 4.5 for
qtlua). 


